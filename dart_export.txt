Verzeichnisstruktur des lib-Ordners:

└── calendar/
    └── event_data_source.dart
└── features/
    ├── event_import_export/
    │   ├── backup_restore_dialogs.dart
    │   ├── event_backup_restorer.dart
    │   ├── event_exporter.dart
    │   └── event_importer.dart
    ├── event_management/
    │   └── event_controller.dart
└── generated/
└── models/
    └── event.dart
└── screens/
    ├── add_event_screen.dart
    ├── calendar_screen.dart
    ├── color_scheme_preview_screen.dart
    ├── event_list_screen.dart
    └── settings_screen.dart
└── services/
    ├── calendar_service.dart
    ├── database_helper.dart
    ├── holiday_service.dart
    ├── notification_service.dart
    ├── share_intent_service.dart
    └── storage_service.dart
└── utils/
    ├── app_colors.dart
    └── calendar_color_logic.dart
└── widgets/
    ├── calendar_app_bar.dart
    ├── calendar_main_body.dart
    └── calendar_month_cell.dart
└── main.dart


================================================================================

Dateiinhalte:

// ==== lib\calendar\event_data_source.dart ====

// lib/calendar/event_data_source

import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_calendar/calendar.dart';
import '../models/event.dart';
import '../utils/calendar_color_logic.dart'; // Wichtig: Passe den Pfad an, falls anders

/// EventDataSource dient als Schnittstelle zwischen den eigenen Event-Daten
/// (Modelklasse `Event`) und dem Syncfusion-Kalender-Widget.
///
/// Sie stellt sicher, dass der Kalender weiß:
/// - Wann ein Termin startet/endet
/// - Welcher Titel angezeigt werden soll
/// - Welche Farbe der Termin hat
/// - Ob es sich um einen Ganztagstermin handelt
class EventDataSource extends CalendarDataSource {
  /// Konstruktor: Übergibt die Eventliste an die `appointments`-Eigenschaft
  /// der Basisklasse `CalendarDataSource`.
  EventDataSource(List<Event> source) {
    appointments = source;
  }

  /// Liefert den Startzeitpunkt eines Termins zurück.
  @override
  DateTime getStartTime(int index) => (appointments![index] as Event).date;

  /// Liefert den Endzeitpunkt eines Termins zurück.
  /// Standardmäßig wird hier eine Stunde nach dem Start angenommen.
  @override
  DateTime getEndTime(int index) =>
      (appointments![index] as Event).date.add(const Duration(hours: 1));

  /// Gibt den Titel (Betreff) des Termins zurück, der im Kalender angezeigt wird.
  @override
  String getSubject(int index) => (appointments![index] as Event).title;

  /// Bestimmt die Farbe des Termins im Kalender.
  @override
  Color getColor(int index) {
    final Event event = appointments![index] as Event;
    return CalendarColorLogic.getEventColor(event);
  }

  /// Definiert, ob es sich bei dem Termin um einen Ganztagstermin handelt.
  @override
  bool isAllDay(int index) {
    final Event event = appointments![index] as Event;
    return event.isHoliday || event.isBirthday;
  }
}


// ==== lib\features\event_import_export\backup_restore_dialogs.dart ====

// lib/features/event_import_export/backup_restore_dialogs.dart

import 'package:flutter/material.dart';
import 'package:ukalender2/utils/app_colors.dart';

Future<String?> showBackupRestoreConfirmationDialog({
  required BuildContext context,
  required Widget contentWidget,
}) {
  String? selectedOption; // 'merge', 'replace'

  return showDialog<String>(
    context: context,
    builder: (BuildContext context) {
      return StatefulBuilder(
        builder: (context, setState) {
          return AlertDialog(
            title: const Text('Backup wiederherstellen'),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                contentWidget,
                const SizedBox(height: 20),
                RadioListTile<String>(
                  title: const Text('Termine zusammenführen'),
                  value: 'merge',
                  groupValue: selectedOption,
                  onChanged: (value) {
                    setState(() {
                      selectedOption = value;
                    });
                  },
                ),
                RadioListTile<String>(
                  title: const Text('Alle Termine ersetzen'),
                  value: 'replace',
                  groupValue: selectedOption,
                  onChanged: (value) {
                    setState(() {
                      selectedOption = value;
                    });
                  },
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('Abbrechen'),
              ),
              ElevatedButton(
                onPressed: selectedOption == null
                    ? null
                    : () => Navigator.of(context).pop(selectedOption),
                style: ElevatedButton.styleFrom(
                  backgroundColor: selectedOption == 'replace'
                      ? AppColors.destructiveActionColor
                      : Theme.of(context).colorScheme.primary,
                  foregroundColor: Colors.white,
                ),
                child: const Text('Bestätigen'),
              ),
            ],
          );
        },
      );
    },
  );
}


// ==== lib\features\event_import_export\event_backup_restorer.dart ====

// lib/features/event_import_export/event_backup_restorer.dart

import 'package:flutter/material.dart';
import '../../models/event.dart';
import '../../services/calendar_service.dart';
import '../../services/storage_service.dart';
import '../../services/notification_service.dart'; // Import hinzufügen
//import '../../utils/app_colors.dart'; // Sicherstellen, dass AppColors importiert wird

class EventBackupRestorer {
  final CalendarService _calendarService;
  final StorageService _storageService;
  final Function() _onEventsRestored; // Callback, um Daten im UI neu zu laden
  final Function(SnackBar) _showSnackBar; // Callback, um SnackBar anzuzeigen
  final Future<String?> Function(Widget content)
  _showConfirmationDialog; // Callback für den Dialog

  EventBackupRestorer({
    required CalendarService calendarService,
    required StorageService storageService,
    required Function() onEventsRestored,
    required Function(SnackBar) showSnackBar,
    required Future<String?> Function(Widget content) showConfirmationDialog,
  }) : _calendarService = calendarService,
       _storageService = storageService,
       _onEventsRestored = onEventsRestored,
       _showSnackBar = showSnackBar,
       _showConfirmationDialog = showConfirmationDialog;

  /// Erstellt ein internes Backup der aktuellen Termine im JSON-Format.
  Future<void> createBackup(List<Event> userEvents) async {
    if (userEvents.isEmpty) {
      _showSnackBar(
        const SnackBar(
          content: Text('Es sind keine Termine für ein Backup vorhanden.'),
        ),
      );
      return;
    }
    await _calendarService.createInternalBackup(userEvents);
    _showSnackBar(
      const SnackBar(content: Text('Backup erfolgreich erstellt.')),
    );
  }

  /// Stellt Termine aus einem internen JSON-Backup wieder her.
  Future<void> restoreBackup() async {
    final List<Event> restoredEvents = await _calendarService
        .restoreFromInternalBackup();

    if (restoredEvents.isEmpty) {
      _showSnackBar(
        const SnackBar(
          content: Text('Wiederherstellung abgebrochen oder Datei ungültig.'),
        ),
      );
      return;
    }

    final choice = await _showConfirmationDialog(
      const Text('Wie möchtest du das Backup einspielen?'),
    );

    if (choice == null) return; // Dialog abgebrochen

    // Vor dem Hinzufügen/Ersetzen alle bestehenden Benachrichtigungen abbrechen,
    // um Duplikate oder veraltete Benachrichtigungen zu vermeiden.
    // Dies ist wichtig, wenn man alle Termine ersetzt.
    if (choice == 'replace') {
      await _storageService.clearAllEvents();
      // Auch alle Benachrichtigungen löschen, da alle alten Events weg sind.
      // Hinweis: NotificationService().cancelAllReminders() wäre ideal,
      // aber ist hier nicht vorhanden. Man müsste dies eventuell implementieren
      // oder sich auf die Benachrichtigungen der hinzugefügten Events konzentrieren.
    }

    for (final event in restoredEvents) {
      await _storageService.addEvent(event);
      // NEU: Benachrichtigungen für wiederhergestellte Events planen
      final int notificationId = event.id.hashCode;
      NotificationService().scheduleReminders(
        notificationId,
        event.title,
        event.date,
      );
    }
    await _onEventsRestored(); // UI informieren, dass Daten neu geladen werden müssen

    _showSnackBar(
      SnackBar(
        content: Text('${restoredEvents.length} Termin(e) wiederhergestellt.'),
      ),
    );
  }
}


// ==== lib\features\event_import_export\event_exporter.dart ====

// lib/features/event_import_export/event_exporter.dart

import 'package:flutter/material.dart';
import '../../models/event.dart';
import '../../services/calendar_service.dart';

class EventExporter {
  final CalendarService _calendarService;
  final Function(SnackBar) _showSnackBar;

  EventExporter({
    required CalendarService calendarService,
    required Function(SnackBar) showSnackBar,
  }) : _calendarService = calendarService,
       _showSnackBar = showSnackBar;

  Future<void> exportEvents(List<Event> userEvents) async {
    if (userEvents.isEmpty) {
      _showSnackBar(
        const SnackBar(
          content: Text('Es sind keine Termine zum Exportieren vorhanden.'),
        ),
      );
      return;
    }
    await _calendarService.exportEvents(userEvents);
    _showSnackBar(
      const SnackBar(content: Text('Termine erfolgreich exportiert.')),
    );
  }
}


// ==== lib\features\event_import_export\event_importer.dart ====

// lib/features/event_import_export/event_importer.dart

import 'package:flutter/material.dart';
import '../../models/event.dart';
import '../../services/calendar_service.dart';
import '../../services/storage_service.dart';
import '../../services/notification_service.dart'; // Import hinzufügen

class EventImporter {
  final CalendarService _calendarService;
  final StorageService _storageService;
  final Function() _onEventsImported; // Callback, um Daten im UI neu zu laden
  final Function(SnackBar) _showSnackBar; // Callback, um SnackBar anzuzeigen

  EventImporter({
    required CalendarService calendarService,
    required StorageService storageService,
    required Function() onEventsImported,
    required Function(SnackBar) showSnackBar,
  }) : _calendarService = calendarService,
       _storageService = storageService,
       _onEventsImported = onEventsImported,
       _showSnackBar = showSnackBar;

  Future<void> importEvents() async {
    final List<Event> importedEvents = await _calendarService
        .importEventsFromPicker();

    if (importedEvents.isNotEmpty) {
      for (final event in importedEvents) {
        await _storageService.addEvent(event);
        // NEU: Benachrichtigungen für importierte Events planen
        final int notificationId = event.id.hashCode;
        NotificationService().scheduleReminders(
          notificationId,
          event.title,
          event.date,
        );
      }
      await _onEventsImported(); // UI informieren, dass Daten neu geladen werden müssen
      _showSnackBar(
        SnackBar(
          content: Text(
            '${importedEvents.length} Termin(e) erfolgreich importiert/aktualisiert.',
          ),
        ),
      );
    } else {
      _showSnackBar(
        const SnackBar(
          content: Text('Import abgebrochen oder keine Termine gefunden.'),
        ),
      );
    }
  }
}


// ==== lib\features\event_management\event_controller.dart ====



// ==== lib\models\event.dart ====

// lib/models/event.dart

import 'package:flutter/material.dart';
import 'package:json_annotation/json_annotation.dart';
import '../utils/app_colors.dart';

part 'event.g.dart';

// Benutzerdefinierte Serialisierungsfunktionen
String _dateToJson(DateTime date) => date.toUtc().toIso8601String();

// Datum als ISO8601 String speichern und in lokale Zeit umwandeln
DateTime _dateFromJson(String dateString) =>
    DateTime.parse(dateString).toLocal();

// Farbe als ARGB int speichern
int _colorToJson(Color color) => color.toARGB32();
Color _colorFromJson(int value) => Color(value);

// Bool als int (0/1) speichern
int _boolToInt(bool b) => b ? 1 : 0;
bool _intToBool(int i) => i == 1;

/// Event Modell mit JSON-Serialisierung
@JsonSerializable()
class Event {
  final String id;
  final String title;
  final String? description;

  // Feiertag als int (0/1) in der DB speichern
  @JsonKey(toJson: _boolToInt, fromJson: _intToBool)
  final bool isHoliday;

  // Geburtstag als int (0/1) in der DB speichern
  @JsonKey(defaultValue: false, toJson: _boolToInt, fromJson: _intToBool)
  final bool isBirthday;

  // Datum als ISO8601 String in der DB speichern
  @JsonKey(toJson: _dateToJson, fromJson: _dateFromJson)
  final DateTime date;

  // Farbe als ARGB int in der DB speichern
  @JsonKey(toJson: _colorToJson, fromJson: _colorFromJson)
  final Color color;

  // Konstruktor
  Event({
    required this.id,
    required this.title,
    this.description,
    required this.date,
    this.isHoliday = false,
    this.isBirthday = false,
    this.color = AppColors.lightBlue,
  });

  // JSON-Deserialisierung (Ein Event-Objekt aus einem Json erzeugen.)
  factory Event.fromJson(Map<String, dynamic> json) => _$EventFromJson(json);

  // JSON-Serialisierung (Ein Json aus einem Event-Objekt erzeugen.)
  Map<String, dynamic> toJson() => _$EventToJson(this);

  // Kopiert das Event mit optionalen neuen Werten
  Event copyWith({
    String? id,
    String? title,
    String? description,
    DateTime? date,
    bool? isHoliday,
    bool? isBirthday,
    Color? color,
  }) {
    return Event(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      date: date ?? this.date,
      isHoliday: isHoliday ?? this.isHoliday,
      isBirthday: isBirthday ?? this.isBirthday,
      color: color ?? this.color,
    );
  }
}


// ==== lib\screens\add_event_screen.dart ====

// lib/screens/add_event_screen.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';
import '../models/event.dart';
import '../services/notification_service.dart';
import '../utils/app_colors.dart';

/// Screen zum Hinzufügen oder Bearbeiten eines Termins
class AddEventScreen extends StatefulWidget {
  final DateTime selectedDate;
  final Event? eventToEdit;

  // Konstruktor
  const AddEventScreen({
    super.key,
    required this.selectedDate,
    this.eventToEdit,
  });

  @override
  State<AddEventScreen> createState() => _AddEventScreenState();
}

/// State-Klasse für den AddEventScreen
class _AddEventScreenState extends State<AddEventScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descController = TextEditingController();
  late DateTime _selectedDate;
  late TimeOfDay _selectedTime;
  late Color _selectedColor;
  bool _isBirthday = false;

  // UUID-Generator für eindeutige IDs
  final Uuid _uuid = const Uuid();

  @override
  void initState() {
    super.initState();
    _selectedDate = widget.selectedDate;

    // Wenn ein Termin bearbeitet wurde.
    if (widget.eventToEdit != null) {
      final event = widget.eventToEdit!;
      _titleController.text = event.title;
      _descController.text = event.description ?? '';
      _selectedDate = event.date;
      _selectedTime = TimeOfDay.fromDateTime(event.date);
      _selectedColor = event.color; // Hintergrundfarbe des Termins (lightBlue)
      _isBirthday = event.isBirthday;
    } else {
      _selectedTime = TimeOfDay.now();
      // Standardfarbe für neue Termine (hellblau)
      _selectedColor = AppColors.eventColors.last;
    }
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descController.dispose();
    super.dispose();
  }

  // Datumsauswahl-Dialog anzeigen
  Future<void> _selectDate() async {
    final pickedDate = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
      locale: const Locale('de', 'DE'),
    );
    if (pickedDate != null && pickedDate != _selectedDate) {
      setState(() {
        _selectedDate = pickedDate;
      });
    }
  }

  // Uhrzeitauswahl-Dialog anzeigen
  Future<void> _selectTime() async {
    final pickedTime = await showTimePicker(
      context: context,
      initialTime: _selectedTime,
    );
    if (pickedTime != null && pickedTime != _selectedTime) {
      setState(() {
        _selectedTime = pickedTime;
      });
    }
  }

  // Farbauswahl-Widget
  Widget _buildColorPicker() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Farbauswahl:', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 10),
        Wrap(
          spacing: 12.0,
          runSpacing: 10.0,
          children: AppColors.eventColors.map((color) {
            final isSelected = _selectedColor == color;
            return GestureDetector(
              onTap: () {
                setState(() {
                  _selectedColor = color;
                });
              },
              // Farbauswahl-Kreis
              child: Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  color: color,
                  shape: BoxShape.circle,
                  border: isSelected
                      ? Border.all(
                          color: AppColors.selectColorChoise,
                          width: 3.0,
                        )
                      : Border.all(
                          color: AppColors.deselectColorChoise,
                          width: 1.5,
                        ),
                ),
                child: isSelected
                    ? const Icon(
                        Icons.check,
                        color: AppColors.checkIcon,
                        size: 22,
                      )
                    : null,
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  // Widget für ein Textfeld mit Titel
  Widget _buildTitledTextField({
    required BuildContext context,
    required String label,
    required TextEditingController controller,
    String? hintText,
    String? Function(String?)? validator,
  }) {
    // Styling für Titel + Beschreibung
    final labelStyle = Theme.of(
      context,
    ).textTheme.titleMedium?.copyWith(color: AppColors.lableTextfield);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: labelStyle),
        const SizedBox(height: 8.0),
        TextFormField(
          controller: controller,
          decoration: InputDecoration(
            hintText: hintText,
            labelText: null,
            border: const UnderlineInputBorder(),
            contentPadding: const EdgeInsets.symmetric(vertical: 10.0),
          ),
          validator: validator,
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.eventToEdit != null;

    return Scaffold(
      // AppBar mit Titel und Lösch-Button (wenn Bearbeitung)
      appBar: AppBar(
        title: Text(
          isEditing ? 'Termin bearbeiten' : 'Termin erstellen',
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        actions: [
          if (isEditing)
            IconButton(
              icon: const Icon(
                Icons.delete_outline,
                size: 25,
                color: AppColors.destructiveActionColor,
              ),
              tooltip: 'Termin löschen',
              onPressed: () async {
                final navigator = Navigator.of(context);
                final confirmDelete = await showDialog<bool>(
                  context: context,
                  builder: (BuildContext context) {
                    return AlertDialog(
                      title: const Text(
                        'Löschen bestätigen',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      // content: const Text(
                      //   'Möchten Sie diesen Termin wirklich endgültig löschen?',
                      // ),
                      actions: <Widget>[
                        // Abbrechen-Button
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(false),
                          child: const Text(
                            'Abbrechen',
                            style: TextStyle(fontSize: 16),
                          ),
                        ),
                        // Löschen-Button
                        TextButton(
                          style: TextButton.styleFrom(
                            foregroundColor: AppColors.deleteButton,
                          ),
                          onPressed: () => Navigator.of(context).pop(true),
                          child: const Text(
                            'Löschen',
                            style: TextStyle(fontSize: 16),
                          ),
                        ),
                      ],
                    );
                  },
                );

                if (!mounted) return;
                if (confirmDelete == true) {
                  navigator.pop(true);
                }
              },
            ),
        ],
      ),
      // Formular zum Eingeben der Termindaten
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildTitledTextField(
                  context: context,
                  label: 'Titel',
                  controller: _titleController,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Bitte geben Sie einen Titel ein.';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                _buildTitledTextField(
                  context: context,
                  label: 'Beschreibung (optional)',
                  controller: _descController,
                ),
                const SizedBox(height: 24),
                SwitchListTile(
                  title: const Text('Jährlicher Geburtstag'),
                  // subtitle: const Text(
                  //   'Der Termin wird jedes Jahr wiederholt.',
                  // ),
                  value: _isBirthday,
                  onChanged: (bool value) {
                    setState(() {
                      _isBirthday = value;
                      if (value) {
                        _selectedColor = AppColors.birthdayColor;
                      } else {
                        _selectedColor = AppColors.defaultEventColor;
                      }
                    });
                  },
                ),
                const SizedBox(height: 16),
                // Datum- und Uhrzeitauswahl
                Row(
                  children: [
                    Expanded(
                      child: TextButton.icon(
                        icon: const Icon(Icons.calendar_today, size: 24),
                        label: Text(
                          DateFormat.yMd('de_DE').format(_selectedDate),
                          style: const TextStyle(fontSize: 17),
                        ),
                        onPressed: _selectDate,
                      ),
                    ),
                    const SizedBox(width: 12),
                    if (!_isBirthday)
                      Expanded(
                        child: TextButton.icon(
                          icon: const Icon(Icons.access_time, size: 24),
                          label: Text(
                            _selectedTime.format(context),
                            style: const TextStyle(fontSize: 17),
                          ),
                          onPressed: _selectTime,
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 24),
                // Farbauswahl
                _buildColorPicker(),
                const SizedBox(height: 30),
                Center(
                  child: ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 50),
                    ),
                    onPressed: () {
                      if (_formKey.currentState!.validate()) {
                        final eventTime = _isBirthday
                            ? const TimeOfDay(hour: 0, minute: 0)
                            : _selectedTime;

                        final eventDateTime = DateTime(
                          _selectedDate.year,
                          _selectedDate.month,
                          _selectedDate.day,
                          eventTime.hour,
                          eventTime.minute,
                        );

                        final String eventId =
                            widget.eventToEdit?.id ?? _uuid.v4();

                        final finalEvent = Event(
                          id: eventId,
                          title: _titleController.text,
                          description: _descController.text.isEmpty
                              ? null
                              : _descController.text,
                          date: eventDateTime,
                          color: _selectedColor,
                          isBirthday: _isBirthday,
                        );
                        // Benachrichtigung planen
                        DateTime notificationDate = finalEvent.date;
                        if (finalEvent.isBirthday) {
                          final now = DateTime.now();
                          DateTime nextBirthday = DateTime(
                            now.year,
                            finalEvent.date.month,
                            finalEvent.date.day,
                          );
                          if (nextBirthday.isBefore(now)) {
                            nextBirthday = DateTime(
                              now.year + 1,
                              finalEvent.date.month,
                              finalEvent.date.day,
                            );
                          }
                          notificationDate = nextBirthday;
                        }

                        final int notificationId = eventId.hashCode;

                        // Vorherige Benachrichtigung löschen (falls vorhanden)
                        NotificationService().scheduleReminders(
                          notificationId,
                          finalEvent.title,
                          notificationDate,
                        );

                        if (!mounted) return;
                        // Zurück zur vorherigen Seite mit dem neuen/aktualisierten Termin
                        Navigator.of(context).pop(finalEvent);
                      }
                    },
                    child: const Text(
                      'Speichern',
                      style: TextStyle(
                        fontSize: 17,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


// ==== lib\screens\calendar_screen.dart ====

// lib/screens/calendar_screen.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_calendar/calendar.dart';
import 'package:ukalender2/calendar/event_data_source.dart';
import '../models/event.dart';
import '../services/holiday_service.dart';
import '../screens/add_event_screen.dart';
import '../services/storage_service.dart';
import '../services/calendar_service.dart';
import '../screens/settings_screen.dart';
import '../services/notification_service.dart';
import '../utils/app_colors.dart';
import '../services/share_intent_service.dart';
import '../features/event_import_export/event_importer.dart';
import '../features/event_import_export/event_exporter.dart';
import '../features/event_import_export/event_backup_restorer.dart';
import 'package:ukalender2/screens/event_list_screen.dart';
import '../features/event_import_export/backup_restore_dialogs.dart';
import '../widgets/calendar_app_bar.dart';
import '../widgets/calendar_main_body.dart';

/// Main-Screen, der den Kalender und die Terminverwaltung anzeigt.
class CalendarScreen extends StatefulWidget {
  const CalendarScreen({super.key});

  @override
  State<CalendarScreen> createState() => _CalendarScreenState();
}

/// State-Klasse für den Kalenderbildschirm.
class _CalendarScreenState extends State<CalendarScreen> {
  List<Event> _userEvents = [];
  List<Event> _holidays = [];
  List<Event> _allEvents = [];
  late EventDataSource _dataSource;
  final DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  late int _currentYear;
  final HolidayService _holidayService = HolidayService();
  final StorageService _storageService = StorageService();
  final CalendarService _calendarService = CalendarService();

  late ShareIntentService _shareIntentService;

  late EventImporter _eventImporter;
  late EventExporter _eventExporter;
  late EventBackupRestorer _eventBackupRestorer;

  // CalendarController kommt aus dem Syncfusion Flutter Calendar Paket.
  // _calendarController <- Instanz von CalendarController()
  final CalendarController _calendarController = CalendarController();

  @override
  void initState() {
    super.initState();
    _selectedDay = _focusedDay;
    _currentYear = _focusedDay.year;
    _dataSource = EventDataSource([]);
    _loadInitialData();

    _shareIntentService = ShareIntentService(
      calendarService: _calendarService,
      storageService: _storageService,
      showSnackBar: (snackBar) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(snackBar);
        }
      },
      onEventsImported: _loadInitialData,
    );
    _shareIntentService.initReceiveSharing();

    _eventImporter = EventImporter(
      calendarService: _calendarService,
      storageService: _storageService,
      onEventsImported: _loadInitialData,
      showSnackBar: (snackBar) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(snackBar);
      },
    );

    _eventExporter = EventExporter(
      calendarService: _calendarService,
      showSnackBar: (snackBar) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(snackBar);
      },
    );

    _eventBackupRestorer = EventBackupRestorer(
      calendarService: _calendarService,
      storageService: _storageService,
      onEventsRestored: _loadInitialData,
      showSnackBar: (snackBar) {
        if (mounted) ScaffoldMessenger.of(context).showSnackBar(snackBar);
      },
      showConfirmationDialog: (contentWidget) =>
          showBackupRestoreConfirmationDialog(
            context: context,
            contentWidget: contentWidget,
          ),
    );
  }

  @override
  void dispose() {
    _shareIntentService.dispose();
    _calendarController.dispose();
    super.dispose();
  }

  Future<void> _loadInitialData() async {
    _userEvents = await _storageService.loadEvents();
    await _loadHolidaysForYear(_currentYear);
  }

  Future<void> _loadHolidaysForYear(int year) async {
    final stateCode = await _storageService.getSelectedState();
    _holidays = await _holidayService.getHolidays(year, stateCode);
    _rebuildEventListAndRefreshDataSource();
  }

  void _rebuildEventListAndRefreshDataSource() {
    setState(() {
      final List<Event> displayEvents = [];
      displayEvents.addAll(_userEvents.where((event) => !event.isBirthday));

      final birthdayEvents = _userEvents.where((event) => event.isBirthday);
      for (final birthday in birthdayEvents) {
        for (int yearOffset = -1; yearOffset <= 1; yearOffset++) {
          final targetYear = _currentYear + yearOffset;
          final birthdayInYear = DateTime(
            targetYear,
            birthday.date.month,
            birthday.date.day,
          );
          displayEvents.add(birthday.copyWith(date: birthdayInYear));
        }
      }

      _allEvents = [...displayEvents, ..._holidays];
      _dataSource = EventDataSource(_allEvents);
      _dataSource.notifyListeners(CalendarDataSourceAction.reset, _allEvents);
    });
  }

  void _onCalendarTapped(CalendarTapDetails details) {
    setState(() {
      _selectedDay = details.date;
    });
  }

  void _addEvent(Event event) {
    _storageService.addEvent(event).then((_) {
      if (!mounted) return;
      _loadInitialData();
    });
  }

  void _deleteEvent(Event event) {
    if (event.isHoliday) return;
    final int notificationId = event.id.hashCode;
    NotificationService().cancelReminders(notificationId);
    _storageService.deleteEvent(event.id).then((_) {
      if (!mounted) return;
      _loadInitialData();
    });
  }

  void _updateEvent(Event oldEvent, Event newEvent) {
    final int oldNotificationId = oldEvent.id.hashCode;
    NotificationService().cancelReminders(oldNotificationId);
    _storageService.updateEvent(newEvent).then((_) {
      if (!mounted) return;
      _loadInitialData();
    });
  }

  void _handleAppBarAction(String value) {
    switch (value) {
      case 'export_ics':
        _exportEvents();
        break;
      case 'import_ics':
        _importEvents();
        break;
      case 'backup_json':
        _performBackup();
        break;
      case 'restore_json':
        _performRestore();
        break;
    }
  }

  void _importEvents() async {
    await _eventImporter.importEvents();
  }

  void _exportEvents() async {
    await _eventExporter.exportEvents(_userEvents);
  }

  void _performBackup() async {
    await _eventBackupRestorer.createBackup(_userEvents);
  }

  void _performRestore() async {
    await _eventBackupRestorer.restoreBackup();
  }

  void _openSettings() async {
    final shouldReload = await Navigator.push<bool>(
      context,
      MaterialPageRoute(builder: (_) => const SettingsScreen()),
    );
    if (shouldReload == true) {
      _loadHolidaysForYear(_currentYear);
    }
  }

  void _onCalendarViewChanged(ViewChangedDetails details) {
    final newYear = details.visibleDates.first.year;
    if (newYear != _currentYear) {
      setState(() {
        _currentYear = newYear;
        _loadHolidaysForYear(newYear);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final Color startColor = Color.lerp(
      colorScheme.surface,
      colorScheme.primaryContainer,
      0.3,
    )!;
    final Color endColor = colorScheme.surfaceContainerLow;
    // Struktur des Kalender-Screens
    return Scaffold(
      // Benutzerdefinierte AppBar
      // CalendarAppBar Widget (lib/widgets/calendar_app_bar.dart)
      appBar: CalendarAppBar(
        calendarController: _calendarController,
        // Callback-Funktion (Bedienungen in der AppBar)
        onListPressed: () {
          // Terminliste aufrufen
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => EventListScreen(
                // Liste mit den Events übergeben
                allEvents: _allEvents,
                // Events ab dem aktuellen Datum anzeigen
                initialSelectedDate: _selectedDay,
              ),
            ),
          );
        },
        // Callback-Funktionen
        onPreviousMonth: () => _calendarController.backward!(),
        onNextMonth: () => _calendarController.forward!(),
        onActionSelected: _handleAppBarAction,
        onSettingsPressed: _openSettings,
      ),

      extendBodyBehindAppBar: true,

      // Kalendergitter (lib/widgets/calendar_main_body.dart)
      body: CalendarMainBody(
        calendarController: _calendarController,
        dataSource: _dataSource,
        initialDisplayDate: _focusedDay,
        selectedDay: _selectedDay,
        // Callback-Funktion
        onCalendarTapped: _onCalendarTapped,
        userEvents: _userEvents,
        onUpdateEvent: _updateEvent,
        onDeleteEvent: _deleteEvent,
        onViewChanged: _onCalendarViewChanged,
        startColor: startColor,
        endColor: endColor,
        focusedDay: _focusedDay,
      ),

      // Termine erstellen
      floatingActionButton: FloatingActionButton(
        backgroundColor: AppColors.floatingActionButton,
        onPressed: () async {
          final result = await Navigator.push<Event>(
            context,
            MaterialPageRoute(
              builder: (_) =>
                  AddEventScreen(selectedDate: _selectedDay ?? DateTime.now()),
            ),
          );
          if (result != null) {
            _addEvent(result);
          }
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}


// ==== lib\screens\color_scheme_preview_screen.dart ====

// // lib/screens/color_scheme_preview_screen.dart

// import 'package:flutter/material.dart';

// class ColorSchemePreviewScreen extends StatelessWidget {
//   const ColorSchemePreviewScreen({super.key});

//   @override
//   Widget build(BuildContext context) {
//     final scheme = Theme.of(context).colorScheme;

//     // Eine umfassende Liste aller Farben im ColorScheme
//     final List<MapEntry<String, Color>> colorEntries = [
//       MapEntry('primary', scheme.primary),
//       MapEntry('onPrimary', scheme.onPrimary),
//       MapEntry('primaryContainer', scheme.primaryContainer),
//       MapEntry('onPrimaryContainer', scheme.onPrimaryContainer),
//       MapEntry('secondary', scheme.secondary),
//       MapEntry('onSecondary', scheme.onSecondary),
//       MapEntry('secondaryContainer', scheme.secondaryContainer),
//       MapEntry('onSecondaryContainer', scheme.onSecondaryContainer),
//       MapEntry('tertiary', scheme.tertiary),
//       MapEntry('onTertiary', scheme.onTertiary),
//       MapEntry('tertiaryContainer', scheme.tertiaryContainer),
//       MapEntry('onTertiaryContainer', scheme.onTertiaryContainer),
//       MapEntry('error', scheme.error),
//       MapEntry('onError', scheme.onError),
//       MapEntry('errorContainer', scheme.errorContainer),
//       MapEntry('onErrorContainer', scheme.onErrorContainer),
//       MapEntry('surface', scheme.surface),
//       MapEntry('onSurface', scheme.onSurface),
//       MapEntry('surface', scheme.surface),
//       MapEntry('onSurface', scheme.onSurface),
//       MapEntry('surfaceContainerHighest', scheme.surfaceContainerHighest),
//       MapEntry('onSurfaceVariant', scheme.onSurfaceVariant),
//       MapEntry('outline', scheme.outline),
//       MapEntry('outlineVariant', scheme.outlineVariant),
//       MapEntry('inverseSurface', scheme.inverseSurface),
//       MapEntry('onInverseSurface', scheme.onInverseSurface),
//       MapEntry('inversePrimary', scheme.inversePrimary),
//       MapEntry('surfaceTint', scheme.surfaceTint),
//     ];

//     return Scaffold(
//       appBar: AppBar(title: const Text("Vorschau: ColorScheme")),
//       body: GridView.builder(
//         gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
//           crossAxisCount: 2, // 2 Spalten
//           childAspectRatio: 2, // Breiter als hoch
//         ),
//         itemCount: colorEntries.length,
//         itemBuilder: (context, index) {
//           final entry = colorEntries[index];
//           final colorName = entry.key;
//           final colorValue = entry.value;

//           // Bestimmt, ob der Text hell oder dunkel sein sollte für beste Lesbarkeit
//           final textColor =
//               ThemeData.estimateBrightnessForColor(colorValue) ==
//                   Brightness.dark
//               ? Colors.white
//               : Colors.black;

//           return Container(
//             color: colorValue,
//             margin: const EdgeInsets.all(2),
//             padding: const EdgeInsets.all(8),
//             child: Center(
//               child: Text(
//                 colorName,
//                 textAlign: TextAlign.center,
//                 style: TextStyle(
//                   color: textColor,
//                   fontWeight: FontWeight.bold,
//                   shadows: [
//                     Shadow(
//                       blurRadius: 2.0,
//                       color: textColor == Colors.white
//                           ? Colors.black
//                           : Colors.white,
//                       offset: const Offset(1.0, 1.0),
//                     ),
//                   ],
//                 ),
//               ),
//             ),
//           );
//         },
//       ),
//     );
//   }
// }


// ==== lib\screens\event_list_screen.dart ====

// lib/screens/event_list_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:scrollable_positioned_list/scrollable_positioned_list.dart';
import '../models/event.dart';
import '../utils/app_colors.dart';
import '../utils/calendar_color_logic.dart';

/// Ein Screen, der eine chronologische Liste aller Kalenderereignisse anzeigt.
class EventListScreen extends StatefulWidget {
  final List<Event> allEvents;
  final DateTime? initialSelectedDate;

  const EventListScreen({
    super.key,
    required this.allEvents,
    this.initialSelectedDate,
  });

  @override
  State<EventListScreen> createState() => _EventListScreenState();
}

class _EventListScreenState extends State<EventListScreen> {
  final ItemScrollController _itemScrollController = ItemScrollController();
  final ItemPositionsListener _itemPositionsListener =
      ItemPositionsListener.create();

  late Map<DateTime, List<Event>> _groupedEvents;
  late List<MapEntry<DateTime, List<Event>>> _sortedGroupedEntries;

  @override
  void initState() {
    super.initState();
    // Events gruppieren und sortieren
    _groupedEvents = _groupEventsByDate(widget.allEvents);
    _groupedEvents.forEach((date, events) {
      events.sort(
        (a, b) => a.date.compareTo(b.date),
      ); // Sortiere Events innerhalb eines Tages nach Uhrzeit
    });
    _sortedGroupedEntries = _groupedEvents.entries.toList();

    // Scrollen, sobald die Liste gerendert ist
    _itemPositionsListener.itemPositions.addListener(_handleScroll);
  }

  void _handleScroll() {
    if (_itemScrollController.isAttached) {
      _itemPositionsListener.itemPositions.removeListener(
        _handleScroll,
      ); // Listener entfernen, um Mehrfachausführung zu verhindern
      _scrollToFirstUpcomingEvent();
    }
  }

  @override
  void dispose() {
    _itemPositionsListener.itemPositions.removeListener(
      _handleScroll,
    ); // Sicherstellen, dass der Listener entfernt wird
    super.dispose();
  }

  /// Gruppiert eine Liste von Events nach ihrem Datum (ohne Zeitkomponente).
  Map<DateTime, List<Event>> _groupEventsByDate(List<Event> events) {
    Map<DateTime, List<Event>> groupedEvents = {};
    for (var event in events) {
      // Datum normalisieren, um Zeitkomponente für die Gruppierung zu entfernen
      DateTime dateOnly = DateTime(
        event.date.year,
        event.date.month,
        event.date.day,
      );
      if (!groupedEvents.containsKey(dateOnly)) {
        groupedEvents[dateOnly] = [];
      }
      groupedEvents[dateOnly]!.add(event);
    }
    // Schlüssel (Daten) chronologisch sortieren
    final sortedKeys = groupedEvents.keys.toList()
      ..sort((a, b) => a.compareTo(b));
    return {for (var k in sortedKeys) k: groupedEvents[k]!};
  }

  /// Scrollt die Liste zum ersten Eintrag, der am oder nach dem aktuellen Tag liegt.
  void _scrollToFirstUpcomingEvent() {
    if (_sortedGroupedEntries.isEmpty) {
      debugPrint('EventListScreen: Liste leer, kein Scrollen möglich.');
      return;
    }

    final now = DateTime.now();
    // Bestimme den aktuellen Tag ohne Zeitkomponente.
    DateTime today = DateTime(now.year, now.month, now.day);

    debugPrint('EventListScreen: Aktuelles Datum (ohne Zeit): $today');
    debugPrint(
      'EventListScreen: Anzahl der gruppierten Termine: ${_sortedGroupedEntries.length}',
    );

    int targetScrollIndex = 0; // Standardmäßig am Anfang der Liste bleiben
    bool foundTarget = false;

    // Finde den Index des ersten Datumseintrags, der am oder nach 'today' liegt.
    for (int i = 0; i < _sortedGroupedEntries.length; i++) {
      final DateTime groupDate = _sortedGroupedEntries[i].key;
      // Wir suchen das erste Event, das am oder nach dem heutigen Tag liegt.
      if (groupDate.isAtSameMomentAs(today) || groupDate.isAfter(today)) {
        targetScrollIndex = i;
        foundTarget = true;
        // debugPrint(
        //   'EventListScreen: Ziel gefunden bei Index $i für Datum $groupDate',
        // );
        break;
      }
    }

    if (foundTarget) {
      debugPrint(
        'EventListScreen: final targetScrollIndex: $targetScrollIndex',
      );

      if (_itemScrollController.isAttached) {
        _itemScrollController.scrollTo(
          index: targetScrollIndex,
          duration: const Duration(milliseconds: 500),
          curve: Curves.easeOut,
          // Bringt das Element an den oberen Rand des Viewports
          alignment: 0.0,
        );
        debugPrint(
          'EventListScreen: Scrollen mit ItemScrollController eingeleitet.',
        );
      } else {
        debugPrint(
          'EventListScreen: ItemScrollController nicht bereit, kann nicht scrollen.',
        );
      }
    } else {
      debugPrint(
        'EventListScreen: Kein Termin am heutigen Tag oder später gefunden. Liste bleibt am Anfang.',
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Terminliste'),
        backgroundColor: Colors.transparent,
        elevation: 0,
        systemOverlayStyle: const SystemUiOverlayStyle(
          statusBarColor: Colors.transparent,
          statusBarIconBrightness: Brightness.dark,
          statusBarBrightness: Brightness.light,
        ),
      ),
      extendBodyBehindAppBar: true,
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Theme.of(context).colorScheme.surfaceContainer,
              Theme.of(context).colorScheme.surfaceContainerLow,
            ],
          ),
        ),
        padding: EdgeInsets.only(
          top: kToolbarHeight + MediaQuery.of(context).padding.top,
        ),
        child: _sortedGroupedEntries.isEmpty
            ? const Center(
                child: Text(
                  'Keine Termine vorhanden.',
                  style: TextStyle(fontSize: 18, color: AppColors.textPrimary),
                ),
              )
            : ScrollablePositionedList.builder(
                itemScrollController: _itemScrollController,
                itemPositionsListener: _itemPositionsListener,
                itemCount: _sortedGroupedEntries.length,
                itemBuilder: (context, index) {
                  final date = _sortedGroupedEntries[index].key;
                  final eventsForDate = _sortedGroupedEntries[index].value;

                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16.0,
                          vertical: 8.0,
                        ),
                        child: Text(
                          '${DateFormat.EEEE('de_DE').format(date)}, ${DateFormat.yMMMMd('de_DE').format(date)}',
                          style: Theme.of(context).textTheme.headlineSmall
                              ?.copyWith(
                                color: Theme.of(context).colorScheme.primary,
                                fontWeight: FontWeight.bold,
                                fontSize: 18,
                              ),
                        ),
                      ),
                      ...eventsForDate.map((event) {
                        final displayColor = CalendarColorLogic.getEventColor(
                          event,
                        );
                        return Card(
                          margin: const EdgeInsets.symmetric(
                            horizontal: 16.0,
                            vertical: 4.0,
                          ),
                          elevation: 1,
                          child: Padding(
                            padding: const EdgeInsets.all(12.0),
                            child: Row(
                              children: [
                                Container(
                                  width: 5.0,
                                  height:
                                      event.description != null &&
                                          event.description!.isNotEmpty
                                      ? 70.0
                                      : 50.0,
                                  decoration: BoxDecoration(
                                    color: displayColor,
                                    borderRadius: BorderRadius.circular(2.5),
                                  ),
                                  margin: const EdgeInsets.only(right: 12.0),
                                ),
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        event.isHoliday
                                            ? 'Ganztägig (Feiertag)'
                                            : (event.isBirthday
                                                  ? 'Ganztägig (Geburtstag)'
                                                  : DateFormat.Hm(
                                                      'de_DE',
                                                    ).format(event.date)),
                                        style: const TextStyle(
                                          fontWeight: FontWeight.bold,
                                          fontSize: 15,
                                          color: AppColors.textPrimary,
                                        ),
                                      ),
                                      const SizedBox(height: 4),
                                      Text(
                                        event.title,
                                        style: Theme.of(context)
                                            .textTheme
                                            .titleMedium
                                            ?.copyWith(
                                              fontWeight: FontWeight.bold,
                                              color: AppColors.textPrimary,
                                            ),
                                        maxLines: 2,
                                        overflow: TextOverflow.ellipsis,
                                      ),
                                      if (event.description != null &&
                                          event.description!.isNotEmpty)
                                        Text(
                                          event.description!,
                                          style: Theme.of(context)
                                              .textTheme
                                              .bodyMedium
                                              ?.copyWith(color: AppColors.grey),
                                          maxLines: 2,
                                          overflow: TextOverflow.ellipsis,
                                        ),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        );
                      }),
                    ],
                  );
                },
              ),
      ),
    );
  }
}


// ==== lib\screens\settings_screen.dart ====

// lib/screens/settings_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:package_info_plus/package_info_plus.dart';
import '../generated/build_info.dart';
import '../services/notification_service.dart';
import '../services/storage_service.dart';

/// Screen für die Einstellungen der App.
class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

/// State-Klasse für den SettingsScreen.
class _SettingsScreenState extends State<SettingsScreen> {
  final StorageService _storageService = StorageService();
  String _selectedStateCode = 'NW';
  PackageInfo _packageInfo = PackageInfo(
    appName: 'Unknown',
    packageName: 'Unknown',
    version: 'Unknown',
    buildNumber: 'Unknown',
  );

  // Controller für die Textfelder der Erinnerungszeiten
  late TextEditingController _reminder1Controller;
  late TextEditingController _reminder2Controller;

  bool _isTestNotificationMode = false;

  // Deutsche Bundesländer und deren Codes
  final Map<String, String> _germanStates = {
    'NATIONAL': 'Bundesweit',
    'BW': 'Baden-Württemberg',
    'BY': 'Bayern',
    'BE': 'Berlin',
    'BB': 'Brandenburg',
    'HB': 'Bremen',
    'HH': 'Hamburg',
    'HE': 'Hessen',
    'MV': 'Mecklenburg-Vorpommern',
    'NI': 'Niedersachsen',
    'NW': 'Nordrhein-Westfalen',
    'RP': 'Rheinland-Pfalz',
    'SL': 'Saarland',
    'SN': 'Sachsen',
    'ST': 'Sachsen-Anhalt',
    'SH': 'Schleswig-Holstein',
    'TH': 'Thüringen',
  };

  @override
  void initState() {
    super.initState();
    _reminder1Controller = TextEditingController();
    _reminder2Controller = TextEditingController();
    _loadAllSettings();
    _loadPackageInfo();
  }

  @override
  void dispose() {
    _reminder1Controller.dispose();
    _reminder2Controller.dispose();
    super.dispose();
  }

  /// Lädt alle gespeicherten Einstellungen und aktualisiert den State.
  Future<void> _loadAllSettings() async {
    final savedState = await _storageService.getSelectedState();
    final reminderMinutes = await _storageService.getReminderMinutes();
    final isTestMode = await _storageService.getIsTestNotification();

    if (mounted) {
      setState(() {
        _selectedStateCode = savedState;
        _isTestNotificationMode = isTestMode;

        if (_isTestNotificationMode) {
          _reminder1Controller.text = reminderMinutes['reminder1']!.toString();
          _reminder2Controller.text = reminderMinutes['reminder2']!.toString();
        } else {
          _reminder1Controller.text = '1440';
          _reminder2Controller.text = '60';
        }
      });
    }
  }

  /// Lädt die Paketinformationen der App.
  Future<void> _loadPackageInfo() async {
    final info = await PackageInfo.fromPlatform();
    if (mounted) {
      setState(() {
        _packageInfo = info;
      });
    }
  }

  /// Handler für die Auswahl eines Bundeslandes.
  void _onStateSelected(String? newCode) {
    if (newCode != null) {
      setState(() {
        _selectedStateCode = newCode;
      });
      _storageService.saveSelectedState(newCode);
    }
  }

  /// Speichert die Erinnerungszeiten, wenn der Testmodus aktiv ist.
  void _saveReminderSettings() {
    FocusScope.of(context).unfocus();

    if (_isTestNotificationMode) {
      final reminder1 = int.tryParse(_reminder1Controller.text) ?? 0;
      final reminder2 = int.tryParse(_reminder2Controller.text) ?? 0;
      _storageService.saveReminderMinutes(reminder1, reminder2);

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Test-Erinnerungszeiten gespeichert.'),
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  /// Baut den Titel für einen Abschnitt im Einstellungsbildschirm.
  Widget _buildSectionTitle(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16.0, 20.0, 16.0, 8.0),
      child: Text(
        title,
        style: Theme.of(context).textTheme.titleMedium?.copyWith(
          color: Theme.of(
            context,
          ).colorScheme.primary, // dunkles grün (#006C4E)
          fontWeight: FontWeight.bold,
          fontSize: 19,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      extendBodyBehindAppBar: true,
      body: PopScope(
        canPop: false,
        onPopInvokedWithResult: (bool didPop, Object? result) {
          if (didPop) return;
          Navigator.of(context).pop(true);
        },
        // Der Hintergrund mit Farbverlauf
        child: GestureDetector(
          onTap: () => FocusScope.of(context).unfocus(),
          child: Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [
                  colorScheme.surfaceContainer,
                  colorScheme.surfaceContainerLow,
                ],
              ),
            ),
            // Der eigentliche Inhalt des Bildschirms
            child: ListView(
              children: [
                _buildSectionTitle(context, 'Über die App'),
                // 1. Karte mit App-Informationen.
                Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Column(
                    children: [
                      ListTile(
                        leading: const Icon(Icons.info_outline),
                        title: const Text('App-Version'),
                        subtitle: Text(
                          '${_packageInfo.version}+${_packageInfo.buildNumber}',
                        ),
                      ),
                      ListTile(
                        leading: const Icon(Icons.build_circle_outlined),
                        title: const Text('Build-Zeitpunkt'),
                        subtitle: const Text(BuildInfo.buildTimestamp),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: TextButton(
                          onPressed: () {
                            NotificationService().showTestNotification();
                          },
                          child: const Text('SOFORT-BENACHRICHTIGUNG TESTEN'),
                        ),
                      ),
                    ],
                  ),
                ),
                // Abschnitt für Benachrichtigungseinstellungen
                _buildSectionTitle(context, 'Benachrichtigungen'),
                // 2. Karte mit Benachrichtigungseinstellungen.
                Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          !_isTestNotificationMode
                              ? 'Standardmodus: Erinnerungen erfolgen 24h und 1h vor einem Termin.'
                              : 'Testmodus: Definieren Sie die Erinnerungszeiten in Minuten.',
                        ),
                        const SizedBox(height: 16),
                        // Zwei Textfelder für die Erinnerungszeiten
                        Row(
                          children: [
                            Expanded(
                              child: TextField(
                                enabled: _isTestNotificationMode,
                                controller: _reminder1Controller,
                                decoration: const InputDecoration(
                                  labelText: '1. Erinnerung (Min.)',
                                  border: OutlineInputBorder(),
                                ),
                                keyboardType: TextInputType.number,
                                inputFormatters: [
                                  FilteringTextInputFormatter.digitsOnly,
                                ],
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: TextField(
                                enabled: _isTestNotificationMode,
                                controller: _reminder2Controller,
                                decoration: const InputDecoration(
                                  labelText: '2. Erinnerung (Min.)',
                                  border: OutlineInputBorder(),
                                ),
                                keyboardType: TextInputType.number,
                                inputFormatters: [
                                  FilteringTextInputFormatter.digitsOnly,
                                ],
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        // Umschalter für den Testmodus
                        Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            const Text('Standard'),
                            // Der Umschalter
                            Switch(
                              value: _isTestNotificationMode,
                              onChanged: (value) {
                                setState(() {
                                  _isTestNotificationMode = value;
                                  if (value) {
                                    _storageService.getReminderMinutes().then((
                                      minutes,
                                    ) {
                                      _reminder1Controller.text =
                                          minutes['reminder1']!.toString();
                                      _reminder2Controller.text =
                                          minutes['reminder2']!.toString();
                                    });
                                  } else {
                                    _reminder1Controller.text = '1440';
                                    _reminder2Controller.text = '60';
                                  }
                                });
                                _storageService.saveIsTestNotification(value);
                              },
                            ),
                            const Text('Test'),
                            const Spacer(),
                            ElevatedButton(
                              onPressed: _isTestNotificationMode
                                  ? _saveReminderSettings
                                  : null,
                              child: const Text('Speichern'),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
                // Abschnitt für die Auswahl des Bundeslandes
                _buildSectionTitle(context, 'Feiertage'),
                // 3. Karte mit Auswahl der Bundesländer bezüglich der Feiertage.
                Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16.0,
                      vertical: 4.0,
                    ),
                    child: DropdownButton<String>(
                      value: _selectedStateCode,
                      onChanged: _onStateSelected,
                      underline: const SizedBox(),
                      isExpanded: true,
                      items: _germanStates.entries.map((entry) {
                        return DropdownMenuItem<String>(
                          value: entry.key,
                          child: Text(entry.value),
                        );
                      }).toList(),
                    ),
                  ),
                ),
                const SizedBox(height: 20), // Abstand am Ende
              ],
            ),
          ),
        ),
      ),
    );
  }
}


// ==== lib\services\calendar_service.dart ====

// lib/services/calendar_service.dart

import 'dart:io';
import 'dart:convert'; // Für JSON-Kodierung und -Dekodierung
import 'package:add_2_calendar/add_2_calendar.dart' as a2c;
import 'package:file_picker/file_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:icalendar_parser/icalendar_parser.dart' as ical_parser;
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';
import '../models/event.dart' as my_event;

/// Service-Klasse für Kalenderbezogene Funktionen wie Export, Import und Backup von Terminen.
class CalendarService {
  final Uuid _uuid = const Uuid();

  /// Fügt ein Ereignis zum Gerätekalender hinzu.
  Future<void> addToDeviceCalendar(my_event.Event event) async {
    final a2c.Event a2cEvent = a2c.Event(
      title: event.title,
      description: event.description ?? '',
      startDate: event.date,
      endDate: event.date.add(const Duration(hours: 1)),
      allDay: event.isBirthday,
    );
    await a2c.Add2Calendar.addEvent2Cal(a2cEvent);
  }

  /// Exportiert eine Liste von Ereignissen in eine .ics-Datei und teilt diese Datei.
  Future<void> exportEvents(List<my_event.Event> events) async {
    final StringBuffer icsContent = StringBuffer();
    icsContent.writeln('BEGIN:VCALENDAR');
    icsContent.writeln('VERSION:2.0');
    icsContent.writeln('PRODID:-//My Flutter App//DE');

    String escapeText(String? text) {
      if (text == null || text.isEmpty) return '';
      return text.replaceAll('\n', '\\n');
    }

    for (var event in events) {
      if (event.isHoliday) continue;
      final uid = event.id;
      final title = escapeText(event.title);
      final description = escapeText(event.description);
      final dtstamp = DateFormat(
        "yyyyMMdd'T'HHmmss'Z'",
      ).format(DateTime.now().toUtc());

      icsContent.writeln('BEGIN:VEVENT');
      icsContent.writeln('UID:$uid@meine.app');
      icsContent.writeln('DTSTAMP:$dtstamp');
      icsContent.writeln('SUMMARY:$title');
      if (description.isNotEmpty) {
        icsContent.writeln('DESCRIPTION:$description');
      }
      if (event.isBirthday) {
        final date = event.date;
        final nextDay = DateTime(
          date.year,
          date.month,
          date.day,
        ).add(const Duration(days: 1));
        final dtstart = DateFormat('yyyyMMdd').format(date);
        final dtend = DateFormat('yyyyMMdd').format(nextDay);
        icsContent.writeln('DTSTART;VALUE=DATE:$dtstart');
        icsContent.writeln('DTEND;VALUE=DATE:$dtend');
        icsContent.writeln('RRULE:FREQ=YEARLY');
      } else {
        final dtstart = DateFormat(
          "yyyyMMdd'T'HHmmss'Z'",
        ).format(event.date.toUtc());
        final dtend = DateFormat(
          "yyyyMMdd'T'HHmmss'Z'",
        ).format(event.date.add(const Duration(hours: 1)).toUtc());
        icsContent.writeln('DTSTART:$dtstart');
        icsContent.writeln('DTEND:$dtend');
      }
      icsContent.writeln('END:VEVENT');
    }
    icsContent.writeln('END:VCALENDAR');

    final directory = await getTemporaryDirectory();
    final timestamp = DateFormat('yyMMdd-HHmm').format(DateTime.now());
    final path = '${directory.path}/Termine_$timestamp.ics';
    final file = File(path);
    await file.writeAsString(icsContent.toString());

    await SharePlus.instance.share(
      ShareParams(text: 'Hier sind deine Termine', files: [XFile(path)]),
    );
  }

  // ANGEPASST: Umbenannt, um den Zweck (File Picker) klarer zu machen.
  /// Importiert Ereignisse aus einer vom Benutzer über den Datei-Picker ausgewählten .ics-Datei.
  Future<List<my_event.Event>> importEventsFromPicker() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.any,
    );

    if (result == null || result.files.single.path == null) {
      return []; // Benutzer hat den Dialog abgebrochen
    }

    final path = result.files.single.path!;

    // Ruft die neue, wiederverwendbare Methode zur Verarbeitung der Datei auf.
    return parseIcsFile(path);
  }

  // NEU: Die gesamte Parsing-Logik wurde in diese wiederverwendbare Methode ausgelagert.
  /// Parst eine .ics-Datei vom gegebenen Pfad und gibt eine Liste von Events zurück.
  /// Diese Methode wird sowohl vom File Picker als auch vom Share Handler verwendet.
  Future<List<my_event.Event>> parseIcsFile(String path) async {
    // Überprüfen, ob es sich um eine .ics-Datei handelt.
    if (!path.toLowerCase().endsWith('.ics')) {
      //print('CalendarService [ERROR]: Datei ist keine .ics-Datei: $path');
      return [];
    }

    final file = File(path);
    final List<my_event.Event> importedEvents = [];

    try {
      if (!await file.exists()) {
        //print('CalendarService [ERROR]: Datei existiert nicht am Pfad: $path');
        return [];
      }

      final icsString = await file.readAsString();
      final iCalendar = ical_parser.ICalendar.fromString(icsString);

      if (iCalendar.data.isEmpty) {
        // print(
        //   'CalendarService [WARN]: ICS-Datei ist gültig, enthält aber keine Termine.',
        // );
        return [];
      }

      for (var data in iCalendar.data) {
        try {
          if (!data.containsKey('dtstart')) {
            continue; // Ungültiger Eintrag ohne Startdatum
          }
          final ical_parser.IcsDateTime? icsDate = data['dtstart'];
          final DateTime? startDate = icsDate?.toDateTime();
          if (startDate == null) {
            continue; // Ungültiges Startdatum
          }
          final bool isYearly =
              data['rrule']?.toString().contains('FREQ=YEARLY') ?? false;

          importedEvents.add(
            my_event.Event(
              id: data['uid']?.toString() ?? _uuid.v4(),
              title: data['summary']?.toString() ?? '(Ohne Titel)',
              description: data['description']?.toString() ?? '',
              date: startDate.toLocal(),
              isBirthday: isYearly,
            ),
          );
        } catch (e) {
          // print(
          //   'CalendarService [WARN]: Überspringe fehlerhaften Eintrag im ICS: $e',
          // );
          continue;
        }
      }
      // print(
      //   'CalendarService [SUCCESS]: ${importedEvents.length} Termin(e) erfolgreich geparst.',
      // );
      return importedEvents;
    } catch (e) {
      // print(
      //   'CalendarService [CRITICAL ERROR]: Fehler beim Parsen der ICS-Datei: $e',
      // );
      return [];
    }
  }

  /// Erstellt ein vollständiges, app-internes Backup aller User-Termine in einer JSON-Datei.
  Future<void> createInternalBackup(List<my_event.Event> events) async {
    if (events.isEmpty) {
      return;
    }
    final List<Map<String, dynamic>> jsonList = events
        .map((event) => event.toJson())
        .toList();
    const jsonEncoder = JsonEncoder.withIndent('  ');
    final jsonString = jsonEncoder.convert(jsonList);
    final directory = await getTemporaryDirectory();
    final timestamp = DateFormat('yyMMdd-HHmm').format(DateTime.now());
    final path = '${directory.path}/kalender_backup_$timestamp.json';
    final file = File(path);
    await file.writeAsString(jsonString);
    await SharePlus.instance.share(
      ShareParams(text: 'Mein Kalender-Backup', files: [XFile(path)]),
    );
  }

  /// Stellt Termine aus einer app-internen JSON-Backup-Datei wieder her.
  Future<List<my_event.Event>> restoreFromInternalBackup() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['json'],
    );
    if (result != null && result.files.single.path != null) {
      final path = result.files.single.path!;
      final file = File(path);
      try {
        final jsonString = await file.readAsString();
        final List<dynamic> jsonList = jsonDecode(jsonString);
        final List<my_event.Event> restoredEvents = jsonList
            .map(
              (json) => my_event.Event.fromJson(json as Map<String, dynamic>),
            )
            .toList();
        return restoredEvents;
      } catch (e) {
        return [];
      }
    }
    return [];
  }
}


// ==== lib\services\database_helper.dart ====

// lib/services/database_helper.dart

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/event.dart';

/// Singleton-Klasse für die Datenbankverwaltung
class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  // Privater Konstruktor
  DatabaseHelper._init();

  /// Zugriff auf die Datenbank
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('events.db');
    return _database!;
  }

  /// Initialisierung der Datenbank
  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 2,
      onCreate: _createDB,
      onUpgrade: _onUpgrade,
    );
  }

  /// Erstellung der Datenbanktabellen
  Future _createDB(Database db, int version) async {
    const idType = 'TEXT PRIMARY KEY';
    const textType = 'TEXT NOT NULL';
    const textNullableType = 'TEXT NULL';
    const integerType = 'INTEGER NOT NULL';

    await db.execute('''
      CREATE TABLE events (
      id $idType,
      title $textType,
      description $textNullableType,
      date $textType,
      isHoliday $integerType,
      color $integerType,
      isBirthday $integerType DEFAULT 0
      )
      ''');
  }

  /// Datenbank-Upgrade-Logik
  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      await db.execute(
        'ALTER TABLE events ADD COLUMN isBirthday INTEGER NOT NULL DEFAULT 0',
      );
    }
  }

  // Diese Methode fügt einen neuen Termin hinzu.
  Future<void> insertEvent(Event event) async {
    final db = await instance.database;
    await db.insert(
      'events',
      event.toJson(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  /// Diese Methode aktualisiert einen bestehenden Termin.
  Future<void> updateEvent(Event event) async {
    final db = await instance.database;
    await db.update(
      'events',
      event.toJson(),
      where: 'id = ?',
      whereArgs: [event.id],
    );
  }

  /// Diese Methode ruft alle Termine ab.
  Future<List<Event>> getAllEvents() async {
    final db = await instance.database;
    final result = await db.query('events');
    return result.map((json) => Event.fromJson(json)).toList();
  }

  /// Diese Methode löscht einen Termin anhand seiner ID.
  Future<void> deleteEvent(String id) async {
    final db = await instance.database;
    await db.delete('events', where: 'id = ?', whereArgs: [id]);
  }

  /// Diese Methode löscht alle Termine.
  Future<void> deleteAllEvents() async {
    final db = await instance.database;
    await db.delete('events');
  }
}


// ==== lib\services\holiday_service.dart ====

// lib/services/holiday_service.dart

import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:uuid/uuid.dart';
import '../models/event.dart';

/// Dieser Service ist dafür zuständig, Feiertagsdaten von einer externen API abzurufen.
class HolidayService {
  final Uuid _uuid = const Uuid();

  /// Holt eine Liste von Feiertagen für ein bestimmtes Jahr und Bundesland.
  Future<List<Event>> getHolidays(int year, String stateCode) async {
    final url = Uri.parse(
      'https://feiertage-api.de/api/?jahr=$year&nur_land=$stateCode',
    );

    try {
      final response = await http.get(url);

      // Überprüfen, ob die Anfrage erfolgreich war
      if (response.statusCode == 200) {
        final Map<String, dynamic> data = json.decode(response.body);
        final List<Event> holidays = [];
        data.forEach((key, value) {
          holidays.add(
            Event(
              id: _uuid.v4(),
              title: key,
              date: DateTime.parse(value['datum']),
              isHoliday: true,
              color: Colors.green,
            ),
          );
        });
        return holidays;
      } else {
        return [];
      }
    } catch (e, s) {
      debugPrint('Fehler beim Laden der Feiertage: $e');
      debugPrint('StackTrace: $s');
      return [];
    }
  }
}


// ==== lib\services\notification_service.dart ====

// lib/services/notification_service.dart

import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;
import 'package:intl/intl.dart'; // Import hinzufügen für DateFormat
import '../services/storage_service.dart';

/// Service zur Verwaltung von lokalen Benachrichtigungen.
class NotificationService {
  static final NotificationService _notificationService =
      NotificationService._internal();

  factory NotificationService() {
    return _notificationService;
  }

  // Interner Konstruktor
  NotificationService._internal();

  // Instanz des FlutterLocalNotificationsPlugin
  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  // Instanz des StorageService
  final StorageService _storageService = StorageService();

  /// Initialisiert die Benachrichtigungsdienste.
  Future<void> init() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const DarwinInitializationSettings initializationSettingsIOS =
        DarwinInitializationSettings();

    const InitializationSettings initializationSettings =
        InitializationSettings(
          android: initializationSettingsAndroid,
          iOS: initializationSettingsIOS,
        );

    // Initialisiere Zeitzonen
    tz.initializeTimeZones();
    await flutterLocalNotificationsPlugin.initialize(initializationSettings);
  }

  /// Fordert die notwendigen Berechtigungen für Benachrichtigungen an.
  Future<void> requestPermissions() async {}

  /// Zeigt eine sofortige Test-Benachrichtigung an.
  Future<void> showTestNotification() async {
    const AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
          'main_channel',
          'Main Channel',
          channelDescription: 'Main channel for notifications',
          importance: Importance.max,
          priority: Priority.high,
        );
    const NotificationDetails platformDetails = NotificationDetails(
      android: androidDetails,
    );

    await flutterLocalNotificationsPlugin.show(
      99,
      'Test Benachrichtigung',
      'Wenn Sie das sehen, funktioniert der Kanal.',
      platformDetails,
    );
  }

  /// Plant eine Benachrichtigung zu einem bestimmten Zeitpunkt.
  Future<void> scheduleNotification(
    int id,
    String title,
    String body,
    DateTime scheduledTime,
  ) async {
    try {
      await flutterLocalNotificationsPlugin.zonedSchedule(
        id,
        title,
        body,
        tz.TZDateTime.from(scheduledTime, tz.local),
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'main_channel',
            'Main Channel',
            channelDescription: 'Main channel for notifications',
            importance: Importance.max,
            priority: Priority.high,
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
      );
    } catch (e) {
      //print('Fehler beim Planen der Benachrichtigung: $e');
    }
  }

  /// Plant Erinnerungsbenachrichtigungen basierend auf den Einstellungen.
  ///
  /// Diese Methode ermittelt, ob der Testmodus für Benachrichtigungen aktiv ist
  /// und plant entsprechend zwei Erinnerungen für einen Event.
  ///
  /// [baseId] ist die Basis-ID für die Benachrichtigungen. Die erste Benachrichtigung
  /// erhält diese ID, die zweite [baseId + 1]. Dies ermöglicht das gezielte
  /// Löschen oder Aktualisieren von Erinnerungen zu einem Event.
  /// [title] ist der Titel des Events, der in der Benachrichtigung angezeigt wird.
  /// [eventTime] ist der Startzeitpunkt des Termins.
  Future<void> scheduleReminders(
    int baseId,
    String title,
    DateTime eventTime, // Startzeit des Termins
  ) async {
    // Prüfen, welcher Benachrichtigungsmodus (Standard oder Test) aktiv ist.
    final isTestMode = await _storageService.getIsTestNotification();
    // Aktuelle Zeit in der lokalen Zeitzone
    final tz.TZDateTime now = tz.TZDateTime.now(tz.local);

    int reminder1Minutes;
    int reminder2Minutes;
    String reminder1Body;
    String reminder2Body;

    // Im Testmodus werden die benutzerdefinierten Werte aus den Einstellungen verwendet.
    if (isTestMode) {
      final reminderSettings = await _storageService.getReminderMinutes();
      reminder1Minutes = reminderSettings['reminder1']!;
      reminder2Minutes = reminderSettings['reminder2']!;
      reminder1Body = 'Der Termin beginnt in $reminder1Minutes Minuten.';
      reminder2Body = 'Der Termin beginnt in $reminder2Minutes Minuten.';
    } else {
      // Im Standardmodus werden die festen Werte (24h / 2h) verwendet.
      reminder1Minutes = 1440; // 24 * 60
      reminder2Minutes = 120;

      // Initialisiert einen DateFormatter, um die Uhrzeit des Events im Format HH:mm zu erhalten.
      final timeFormat = DateFormat('HH:mm');
      // Setzt den Text für die erste Benachrichtigung (24 Stunden vorher).
      reminder1Body =
          'Der Termin beginnt morgen um ${timeFormat.format(eventTime)} Uhr.';
      // Setzt den Text für die zweite Benachrichtigung (2 Stunden vorher).
      reminder2Body =
          'Der Termin beginnt in 2 Std. um ${timeFormat.format(eventTime)} Uhr.';
    }

    // --- Planung der ersten Benachrichtigung ---
    // Überprüft, ob eine erste Erinnerung geplant werden soll.
    if (reminder1Minutes > 0) {
      // Berechnet den Zeitpunkt für die erste Erinnerung.
      final reminder1Time = eventTime.subtract(
        Duration(minutes: reminder1Minutes),
      );
      // Prüft, ob der berechnete Erinnerungszeitpunkt in der Zukunft liegt.
      if (reminder1Time.isAfter(now)) {
        // Plant die Benachrichtigung unter Verwendung der `scheduleNotification`-Methode.
        await scheduleNotification(
          // Die `baseId` dient als eindeutige ID für diese Benachrichtigung.
          baseId,
          'Erinnerung: $title',
          reminder1Body, // Der zuvor definierte Textkörper der Benachrichtigung
          reminder1Time, // Der Zeitpunkt, wann die Benachrichtigung erscheinen soll
        );
      } else {
        // Optional: Log-Ausgabe oder andere Behandlung, wenn die Erinnerungszeit bereits vergangen ist.
      }
    }

    // --- Planung der zweiten Benachrichtigung ---
    // Überprüft, ob eine zweite Erinnerung geplant werden soll.
    if (reminder2Minutes > 0) {
      final reminder2Time = eventTime.subtract(
        Duration(minutes: reminder2Minutes),
      );
      if (reminder2Time.isAfter(now)) {
        await scheduleNotification(
          baseId + 1,
          'Erinnerung: $title',
          reminder2Body,
          reminder2Time,
        );
      } else {
        // Optional: Log-Ausgabe oder andere Behandlung, wenn die Erinnerungszeit bereits vergangen ist.
      }
    }
  }

  /// Löscht alle geplanten Erinnerungsbenachrichtigungen für einen Termin.
  ///
  /// Diese Methode wird aufgerufen, um alle zuvor geplanten Benachrichtigungen
  /// für ein bestimmtes Event zu entfernen, z.B. wenn ein Event gelöscht oder aktualisiert wird.
  ///
  /// [baseId] ist die Basis-ID des Events. Es werden die Benachrichtigung mit [baseId]
  /// und [baseId + 1] gelöscht.
  Future<void> cancelReminders(int baseId) async {
    // Löscht die erste geplante Benachrichtigung mit der `baseId`.
    await flutterLocalNotificationsPlugin.cancel(baseId);
    // Löscht die zweite geplante Benachrichtigung mit der `baseId + 1`.
    await flutterLocalNotificationsPlugin.cancel(baseId + 1);
  }
}


// ==== lib\services\share_intent_service.dart ====

// lib/services/share_intent_service.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:receive_sharing_intent/receive_sharing_intent.dart';
import '../models/event.dart';
import 'calendar_service.dart';
import 'storage_service.dart';

/// Ein Typedef für einen Callback, der eine SnackBar anzeigt.
/// Ersetzt den direkten Zugriff auf ScaffoldMessenger.of(context)
/// und ermöglicht es dem Service, Nachrichten anzuzeigen, ohne den Context direkt zu halten.
typedef ShowSnackBarCallback = void Function(SnackBar snackBar);

/// Service zur Verarbeitung von geteilten Inhalten (insbesondere ICS-Dateien).
class ShareIntentService {
  final CalendarService _calendarService;
  final StorageService _storageService;
  StreamSubscription? _intentDataStreamSubscription;
  final ShowSnackBarCallback _showSnackBar;
  final VoidCallback
  _onEventsImported; // Callback, um den Kalender zu aktualisieren

  ShareIntentService({
    required CalendarService calendarService,
    required StorageService storageService,
    required ShowSnackBarCallback showSnackBar,
    required VoidCallback onEventsImported,
  }) : _calendarService = calendarService,
       _storageService = storageService,
       _showSnackBar = showSnackBar,
       _onEventsImported = onEventsImported;

  /// Initialisiert den Listener für geteilte Inhalte mit receive_sharing_intent.
  void initReceiveSharing() {
    _intentDataStreamSubscription = ReceiveSharingIntent.instance
        .getMediaStream()
        .listen(
          (List<SharedMediaFile> value) {
            if (value.isNotEmpty) {
              _handleSharedIcsFile(value.first);
            }
          },
          onError: (err) {
            // Optional: Fehlerprotokollierung
            debugPrint(
              "ReceiveSharingIntent [ERROR]: Fehler im Media-Stream: $err",
            );
          },
        );

    ReceiveSharingIntent.instance.getInitialMedia().then((
      List<SharedMediaFile> value,
    ) {
      if (value.isNotEmpty) {
        _handleSharedIcsFile(value.first);
      }
    });
  }

  /// Verarbeitet eine geteilte ICS-Datei von receive_sharing_intent.
  Future<void> _handleSharedIcsFile(SharedMediaFile file) async {
    if (file.path.toLowerCase().endsWith('.ics')) {
      final String path = file.path;

      _showSnackBar(
        const SnackBar(content: Text('Importiere geteilte Termine...')),
      );

      final List<Event> importedEvents = await _calendarService.parseIcsFile(
        path,
      );

      if (importedEvents.isNotEmpty) {
        for (final event in importedEvents) {
          await _storageService.addEvent(event);
        }
        _onEventsImported(); // Benachrichtigt den CalendarScreen, die Daten neu zu laden

        _showSnackBar(
          SnackBar(
            content: Text(
              '${importedEvents.length} Termin(e) erfolgreich importiert.',
            ),
          ),
        );
      } else {
        _showSnackBar(
          const SnackBar(
            content: Text(
              'Import fehlgeschlagen oder keine Termine in der Datei gefunden.',
            ),
          ),
        );
      }
    } else {
      debugPrint(
        "ReceiveSharingIntent: Geteilte Datei ist keine .ics-Datei: ${file.path}",
      );
    }
  }

  /// Beendet das Stream-Abonnement.
  void dispose() {
    _intentDataStreamSubscription?.cancel();
  }
}


// ==== lib\services\storage_service.dart ====

// lib/services/storage_service.dart

import 'package:shared_preferences/shared_preferences.dart';
import '../models/event.dart';
import '../services/database_helper.dart';

/// Dienst zur Verwaltung der Ereignisspeicherung und Benutzereinstellungen.
class StorageService {
  final dbHelper = DatabaseHelper.instance;

  /// Lädt alle Ereignisse aus der lokalen Datenbank.
  Future<List<Event>> loadEvents() async {
    return await dbHelper.getAllEvents();
  }

  /// Fügt ein neues Ereignis zur lokalen Datenbank hinzu.
  Future<void> addEvent(Event event) async {
    await dbHelper.insertEvent(event);
  }

  /// Aktualisiert ein bestehendes Ereignis in der lokalen Datenbank.
  Future<void> updateEvent(Event event) async {
    await dbHelper.updateEvent(event);
  }

  /// Löscht ein Ereignis aus der lokalen Datenbank anhand seiner ID.
  Future<void> deleteEvent(String id) async {
    await dbHelper.deleteEvent(id);
  }

  static const _stateCodeKey = 'user_state_code';
  static const _reminder1MinutesKey = 'reminder_1_minutes';
  static const _reminder2MinutesKey = 'reminder_2_minutes';
  static const _isTestNotificationKey = 'is_test_notification';

  /// Speichert, ob Testbenachrichtigungen aktiviert sind.
  Future<void> saveIsTestNotification(bool isTest) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_isTestNotificationKey, isTest);
  }

  /// Liest, ob Testbenachrichtigungen aktiviert sind.
  Future<bool> getIsTestNotification() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_isTestNotificationKey) ?? false;
  }

  /// Speichert den ausgewählten Bundeslandcode des Benutzers.
  Future<void> saveSelectedState(String stateCode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_stateCodeKey, stateCode);
  }

  /// Liest den ausgewählten Bundeslandcode des Benutzers.
  Future<String> getSelectedState() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_stateCodeKey) ?? 'NW';
  }

  /// Speichert die Erinnerungszeiten in Minuten vor dem Ereignis.
  Future<void> saveReminderMinutes(int reminder1, int reminder2) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_reminder1MinutesKey, reminder1);
    await prefs.setInt(_reminder2MinutesKey, reminder2);
  }

  /// Liest die Erinnerungszeiten in Minuten vor dem Ereignis.
  Future<Map<String, int>> getReminderMinutes() async {
    final prefs = await SharedPreferences.getInstance();
    return {
      // 1. Erinnerung: 24 Stunden (1440 Minuten) vorher.
      'reminder1': prefs.getInt(_reminder1MinutesKey) ?? 1440,
      // 2. Erinnerung: 1 Stunde (60 Minuten) vorher.
      'reminder2': prefs.getInt(_reminder2MinutesKey) ?? 60,
    };
  }

  /// Löscht alle Ereignisse aus der lokalen Datenbank.
  Future<void> clearAllEvents() async {
    await dbHelper.deleteAllEvents();
  }
}


// ==== lib\utils\app_colors.dart ====

// lib/utils/app_colors.dart

import 'package:flutter/material.dart';

/// Definiert eine Sammlung von Farben, die in der App verwendet werden.
class AppColors {
  // Grundfarben
  static const Color orange = Color(0xFFFF5929); // HEX: #ff5929
  static const Color green = Color(0xFF00854D); // HEX: #00854d
  static const Color grey = Color(0xFF636363); // HEX: #636363
  static const Color violet = Color(0xFFAB54B2); // HEX: #ab54b2
  static const Color red = Color(0xFFDF0E07); // HEX: #df0e07
  static const Color blue = Color(0xFF404DAD); // HEX: #404dad
  static const Color lightBlue = Color(0xFF00A1EA); // HEX: #00a1ea

  // UI-Element Farben
  static const Color floatingActionButton = Color.fromARGB(255, 131, 185, 201);
  static const Color selectColorChoise = Colors.black;
  static final Color deselectColorChoise = Colors.grey.shade400;
  static final Color lableTextfield = Colors.grey.shade700;
  static const Color deleteButton = Colors.red;
  static const Color textPrimary = Colors.black87;
  static const Color checkIcon = Colors.white;
  static const Color dayNumberColor = Colors.white;
  static const Color dayNumberInactive = Colors.black26;
  static final Color calendarGridBorder = Colors.grey[300]!;

  static const Color destructiveActionColor = Colors.red;
  // Wir speichern den Alpha-Wert als Integer (80% von 255 = 204).
  // (Ursprunglich: color: eventColor.withAlpha(204),)
  //static const int eventBackgroundAlpha = 204;

  // Abfrage im AddEventScreen
  static const Color birthdayColor = violet;
  static const Color defaultEventColor = lightBlue;

  /// Liste von Farben, die für Ereignisse verwendet werden können.
  static const List<Color> eventColors = [
    orange,
    green,
    grey,
    violet,
    red,
    blue,
    lightBlue,
  ];

  // Kalender-spezifische Farben
  static const Color pastEvent = Color(0xFF00854D);
  static const Color holidayBackground = Color(
    0x2600854D,
  ); // green.withAlpha(38)
  static const Color holidayText = Color(
    0xFF004D2B,
  ); // Etwas dunkleres rot für Text
  static Color weekendDay = Colors.red.withAlpha(204);

  // UI-Element Farben
  //static const Color floatingActionButton = Color.fromARGB(255, 131, 185, 201);
}


// ==== lib\utils\calendar_color_logic.dart ====

// lib/utils/calendar_color_logic.dart

import 'package:flutter/material.dart';
import '../models/event.dart';
import '../utils/app_colors.dart';

/// Logik zur Bestimmung der Farben von Kalenderereignissen.
class CalendarColorLogic {
  /// Bestimmt die Farbe eines Ereignisses basierend auf seinem Datum.
  static Color getEventColor(Event event) {
    // Feiertage behalten ihre definierte Farbe
    if (event.isHoliday) {
      return event.color;
    }

    final DateTime now = DateTime.now();
    final DateTime today = DateTime(now.year, now.month, now.day);
    final DateTime eventDate = DateTime(
      event.date.year,
      event.date.month,
      event.date.day,
    );

    // Ereignisse in der Vergangenheit erhalten eine grüne Farbe
    if (eventDate.isBefore(today)) {
      return AppColors.pastEvent;
    }

    return event.color;
  }
}


// ==== lib\widgets\calendar_app_bar.dart ====

// lib/widgets/calendar_app_bar.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:syncfusion_flutter_calendar/calendar.dart';

/// Funktionen der AppBar
class CalendarAppBar extends StatelessWidget implements PreferredSizeWidget {
  final VoidCallback onListPressed;
  final VoidCallback onPreviousMonth;
  final VoidCallback onNextMonth;
  final Function(String) onActionSelected;
  final VoidCallback onSettingsPressed;
  final CalendarController
  // Der Controller wird hier übergeben
  calendarController;

  const CalendarAppBar({
    super.key,
    required this.onListPressed,
    required this.onPreviousMonth,
    required this.onNextMonth,
    required this.onActionSelected,
    required this.onSettingsPressed,
    required this.calendarController,
  });

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.list, size: 28.0),
        tooltip: 'Terminliste anzeigen',
        onPressed: onListPressed,
      ),
      backgroundColor: Colors.transparent,
      systemOverlayStyle: const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.dark,
        statusBarBrightness: Brightness.light,
      ),
      title: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: const Icon(Icons.arrow_back_ios, size: 23.0),
            tooltip: 'Vorheriger Monat',
            onPressed: () => calendarController.backward!(),
          ),
          const SizedBox(width: 35),
          IconButton(
            icon: const Icon(Icons.arrow_forward_ios, size: 23.0),
            tooltip: 'Nächster Monat',
            onPressed: () => calendarController.forward!(),
          ),
        ],
      ),
      centerTitle: true,
      actions: [
        PopupMenuButton<String>(
          icon: const Icon(Icons.import_export, size: 30.0),
          tooltip: 'Daten importieren/exportieren',
          onSelected: onActionSelected,
          itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
            const PopupMenuItem<String>(
              value: 'export_ics',
              child: ListTile(
                leading: Icon(Icons.arrow_upward),
                title: Text(
                  'Exportieren (.ics)',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
                ),
              ),
            ),
            const PopupMenuItem<String>(
              value: 'import_ics',
              child: ListTile(
                leading: Icon(Icons.arrow_downward),
                title: Text(
                  'Importieren (.ics)',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
                ),
              ),
            ),
            const PopupMenuDivider(),
            const PopupMenuItem<String>(
              value: 'backup_json',
              child: ListTile(
                leading: Icon(Icons.backup_outlined),
                title: Text(
                  'Backup erstellen...',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
                ),
              ),
            ),
            const PopupMenuItem<String>(
              value: 'restore_json',
              child: ListTile(
                leading: Icon(Icons.restore_page_outlined),
                title: Text(
                  'Backup wiederherstellen...',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
                ),
              ),
            ),
          ],
        ),
        IconButton(
          icon: const Icon(Icons.settings, size: 26.0),
          tooltip: 'Einstellungen',
          onPressed: onSettingsPressed,
        ),
      ],
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}


// ==== lib\widgets\calendar_main_body.dart ====

// lib/screens/calendar_screen/widgets/calendar_main_body.dart

import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_calendar/calendar.dart';
import 'package:ukalender2/calendar/event_data_source.dart';
import 'package:ukalender2/models/event.dart';
import 'package:ukalender2/widgets/calendar_month_cell.dart';

class CalendarMainBody extends StatelessWidget {
  final CalendarController calendarController;
  final EventDataSource dataSource;
  final DateTime initialDisplayDate;
  final DateTime? selectedDay;
  final Function(CalendarTapDetails) onCalendarTapped;
  final List<Event> userEvents;
  final Function(Event oldEvent, Event newEvent) onUpdateEvent;
  final Function(Event event) onDeleteEvent;
  final Function(ViewChangedDetails) onViewChanged;
  final Color startColor;
  final Color endColor;
  final DateTime focusedDay;

  const CalendarMainBody({
    super.key,
    required this.calendarController,
    required this.dataSource,
    required this.initialDisplayDate,
    this.selectedDay,
    required this.onCalendarTapped,
    required this.userEvents,
    required this.onUpdateEvent,
    required this.onDeleteEvent,
    required this.onViewChanged,
    required this.startColor,
    required this.endColor,
    required this.focusedDay,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [startColor, endColor],
        ),
      ),
      padding: EdgeInsets.only(
        // Hier wird das Padding weiter angepasst, um den Kalenderinhalt anzuheben
        // Experimentieren Sie mit diesem Wert, um den besten Abstand zu finden.
        // Ein Wert von -45.0 ist ein Startpunkt, da kToolbarHeight etwa 56.0 ist.
        top: MediaQuery.of(context).padding.top + kToolbarHeight - 70.0,
      ),
      child: SfCalendar(
        controller: calendarController,
        view: CalendarView.month,
        dataSource: dataSource,
        initialDisplayDate: initialDisplayDate,
        initialSelectedDate: selectedDay,
        onTap: onCalendarTapped,
        firstDayOfWeek: 1,
        // Reduziert die Höhe des integrierten Kalender-Headers
        headerHeight: 40.0, // Standard ist 40.0. Dies verringert den Platz.
        headerStyle: CalendarHeaderStyle(
          textAlign: TextAlign.center,
          backgroundColor: Colors.transparent,
          textStyle: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: Theme.of(context).colorScheme.primary,
          ),
        ),
        monthCellBuilder: (context, details) {
          return CalendarMonthCell(
            details: details,
            focusedDay: focusedDay,
            selectedDay: selectedDay,
            userEvents: userEvents,
            onUpdateEvent: onUpdateEvent,
            onDeleteEvent: onDeleteEvent,
          );
        },
        monthViewSettings: const MonthViewSettings(
          appointmentDisplayMode: MonthAppointmentDisplayMode.none,
          numberOfWeeksInView: 6,
          showAgenda: false,
        ),
        onViewChanged: onViewChanged,
      ),
    );
  }
}


// ==== lib\widgets\calendar_month_cell.dart ====

// lib/widgets/calendar_month_cell

import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_calendar/calendar.dart';
import '../models/event.dart';
import '../screens/add_event_screen.dart'; // Für AddEventScreen
import '../utils/app_colors.dart';
import '../utils/calendar_color_logic.dart';

/// Ein Widget, das die Darstellung einer einzelnen Monatszelle im Kalender übernimmt.
class CalendarMonthCell extends StatelessWidget {
  final MonthCellDetails details;
  final DateTime focusedDay; // Wird für isCurrentMonth benötigt
  final DateTime? selectedDay; // Wird für isSelected benötigt
  final List<Event>
  userEvents; // Wird benötigt, um originalEvent für Tap zu finden
  final Function(Event originalEvent, Event newEvent) onUpdateEvent;
  final Function(Event eventToDelete) onDeleteEvent;

  const CalendarMonthCell({
    super.key,
    required this.details,
    required this.focusedDay,
    required this.selectedDay,
    required this.userEvents,
    required this.onUpdateEvent,
    required this.onDeleteEvent,
  });

  @override
  Widget build(BuildContext context) {
    final DateTime now = DateTime.now();
    final bool isToday =
        details.date.year == now.year &&
        details.date.month == now.month &&
        details.date.day == now.day;
    final bool isHoliday = details.appointments.any(
      (appointment) => (appointment as Event).isHoliday,
    );
    final bool isWeekend =
        details.date.weekday == DateTime.saturday ||
        details.date.weekday == DateTime.sunday;
    final bool isCurrentMonth = details.date.month == focusedDay.month;
    final bool isSelected =
        selectedDay != null &&
        selectedDay!.year == details.date.year &&
        selectedDay!.month == details.date.month &&
        selectedDay!.day == details.date.day;

    Color dayNumberColor;
    if (isSelected) {
      dayNumberColor = AppColors.dayNumberColor;
    } else if (!isCurrentMonth) {
      dayNumberColor = AppColors.dayNumberInactive;
    } else if (isWeekend && !isHoliday) {
      dayNumberColor = AppColors.weekendDay;
    } else {
      dayNumberColor = AppColors.textPrimary;
    }

    return Container(
      decoration: BoxDecoration(
        color: isHoliday ? AppColors.holidayBackground : Colors.transparent,
        border: Border(
          top: BorderSide(color: AppColors.calendarGridBorder, width: 0.5),
          left: BorderSide(color: AppColors.calendarGridBorder, width: 0.5),
        ),
      ),
      padding: const EdgeInsets.all(2.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            width: 24,
            height: 24,
            alignment: Alignment.center,
            decoration: isSelected
                ? BoxDecoration(
                    color: Theme.of(context).colorScheme.primary,
                    shape: BoxShape.circle,
                  )
                : isToday
                ? BoxDecoration(
                    shape: BoxShape.rectangle,
                    border: Border.all(
                      color: Theme.of(context).colorScheme.tertiary,
                      width: 2.0,
                    ),
                  )
                : null,
            child: Text(
              details.date.day.toString(),
              style: TextStyle(color: dayNumberColor, fontSize: 14),
            ),
          ),
          const SizedBox(height: 2),
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: details.appointments.map((appointment) {
                  final event = appointment as Event;
                  if (event.isHoliday) {
                    return Padding(
                      padding: const EdgeInsets.only(top: 2.0),
                      child: Text(
                        event.title,
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          color: AppColors.holidayText,
                          fontSize: 10.0,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    );
                  }

                  final Color eventColor = CalendarColorLogic.getEventColor(
                    event,
                  );
                  return GestureDetector(
                    onTap: () async {
                      // Hier suchen wir das Original-Event in der _userEvents-Liste
                      // Wichtig: Verwende die übergebene userEvents Liste
                      final Event originalEvent = userEvents.firstWhere(
                        (e) => e.id == event.id,
                        orElse: () =>
                            event, // Fallback, sollte aber nicht passieren
                      );
                      final result = await Navigator.push<dynamic>(
                        context,
                        MaterialPageRoute(
                          builder: (_) => AddEventScreen(
                            selectedDate: originalEvent.date,
                            eventToEdit: originalEvent,
                          ),
                        ),
                      );
                      if (result is Event) {
                        onUpdateEvent(originalEvent, result);
                      } else if (result is bool && result == true) {
                        onDeleteEvent(originalEvent);
                      }
                    },
                    child: Container(
                      margin: const EdgeInsets.only(top: 2.0),
                      padding: const EdgeInsets.symmetric(
                        horizontal: 3.0,
                        vertical: 2.0,
                      ),
                      decoration: BoxDecoration(
                        color: eventColor.withAlpha(204),
                        borderRadius: BorderRadius.circular(0),
                      ),
                      child: Text(
                        event.title,
                        overflow: TextOverflow.clip,
                        softWrap: false,
                        maxLines: 1,
                        textAlign: TextAlign.left,
                        style: const TextStyle(
                          color: AppColors.dayNumberColor,
                          fontSize: 12.2,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  );
                }).toList(),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


// ==== lib\main.dart ====

// lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';
import '../screens/calendar_screen.dart';
import '../services/notification_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Firebase initialisieren.
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  await initializeDateFormatting('de_DE', null);

  // Benachrichtigungsdienst initialisieren und Berechtigungen anfragen.
  await NotificationService().init();
  await NotificationService().requestPermissions();
  runApp(const MyApp());
}

/// Hauptanwendungsklasse.
class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Flutter Terminkalender',

      // Standardfarben und Helligkeit festlegen.
      theme: ThemeData(
        useMaterial3: true,
        // Hauptakzentfarbe der App definieren.
        colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xFF006C4E)),

        // Kartenstil anpassen (settings_screen.dart).
        cardTheme: CardThemeData(
          elevation: 1, // leichte Schattierung
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          color: ColorScheme.fromSeed(
            seedColor: const Color(0xFF006C4E),
            // Helle Farbe für den Kartenhintergrund (abgeleitet von der Akzentfarbe).
          ).surfaceContainerHigh,
        ),
      ),

      // Stellt sprachspezifische Texte und Layouts für die Flutter-Widgets bereit.
      localizationsDelegates: const [
        // Texte, Labels und Fehlermeldungen erscheinen in der Sprache des Geräts.
        GlobalMaterialLocalizations.delegate, // absolut notwendig!
        // Automatische Richtungsunterstützung für Sprachen, die von rechts nach links gelesen werden.
        GlobalWidgetsLocalizations.delegate,
        // Labels in Cupertino-Komponenten werden in der korrekten Sprache angezeigt.
        GlobalCupertinoLocalizations.delegate,
      ],

      // Lokalisierungen und unterstützte Sprachen festlegen.
      supportedLocales: const [Locale('de', 'DE'), Locale('en', 'US')],
      locale: const Locale('de', 'DE'),

      // Startbildschirm der App festlegen.
      home: const CalendarScreen(),
    );
  }
}

